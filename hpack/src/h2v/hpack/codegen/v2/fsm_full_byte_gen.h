// File: fsm_full_byte_gen.h
//
// Generates a single source code "huffman_byte_table.h" for
// Full-byte Huffman Decode

#include <array>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>
#include <vector>

#include "huffman_table.h"

namespace h2v {
namespace codegen {
namespace huffman_full_byte {

struct Node {
  Node* child[2] = {nullptr, nullptr};
  int symbol = -1;  // 0–255: octet value; 256: EOS symbol; -1 for internal node
};

inline int GenerateFsmFullByte(const std::string& out_path) {
  std::ofstream out(out_path, std::ios::trunc);
  if (!out) {
    std::cerr << "Error: cannot open " << out_path << "\n";
    return 1;
  }

  // Build Huffman trie (256 symbols)
  Node* root = new Node();
  for (int sym = 0; sym < 257; ++sym) {
    uint32_t code = codegen::huffman::CODE[sym];
    uint8_t length = codegen::huffman::LEN[sym];
    Node* n = root;
    for (int i = length - 1; i >= 0; --i) {
      int bit = (code >> i) & 1;
      if (!n->child[bit])
        n->child[bit] = new Node();
      n = n->child[bit];
    }
    n->symbol = sym;
  }

  // Index each trie node via BFS
  std::vector<Node*> nodes;
  nodes.reserve(600);
  std::unordered_map<Node*, int> index;
  std::queue<Node*> q;
  q.push(root);
  index[root] = 0;
  nodes.push_back(root);

  while (!q.empty()) {
    Node* cur = q.front();
    q.pop();
    for (int b = 0; b < 2; ++b) {
      Node* c = cur->child[b];
      if (c && index.find(c) == index.end()) {
        int idx = nodes.size();
        index[c] = idx;
        nodes.push_back(c);
        q.push(c);
      }
    }
  }

  // Emit C++ table header
  out << "// @generated by h2v_huffman_gen_v2\n";
  out << "// NOTE: DO NOT EDIT THIS DIRECTLY\n";
  out << "//       IF THIS FILE MISMATCH, HUFFMAN FULL-BYTE DECODE WILL "
         "FAIL.\n";
  out << "// This generated table use by huffman::FastDecode(...)\n"
         "/* clang-format off */\n"
         "#include <cstdint>\n\n"
         "namespace h2v{ "
         "namespace hpack{ "
         "namespace huffman{ "
         "namespace table{\n\n"
         "struct ByteDecodeEntry { \n"
         "  uint16_t next_state;\n"
         "  uint8_t emit_count;\n"
         "  uint8_t symbols[2];\n };\n";

  size_t total = nodes.size() * 256;
  out << "inline constexpr ByteDecodeEntry kByteDecodeTable[" << total
      << "] = {\n";

  // ----------------------------------------------------------------------
  // 1. Compute Emit each decoded (state, byte) entry
  // ----------------------------------------------------------------------
  for (size_t st = 0; st < nodes.size(); ++st) {
    for (int byte = 0; byte < 256; ++byte) {
      Node* curr = nodes[st];
      Node* n = curr;
      std::vector<uint8_t> emits;
      bool error = false;

      // Walk 8 bits
      for (int i = 7; i >= 0; --i) {
        int bit = (byte >> i) & 1;
        n = n->child[bit];
        if (!n) {
          error = true;
          break;
        }
        if (n->symbol >= 0) {
          emits.push_back(static_cast<uint8_t>(n->symbol));
          n = root;
        }
      }

      if (error) {
        out << "  { 0, 0xFF, {0,0} },\n";
      } else {
        int cnt = emits.size();
        uint8_t s0 = cnt > 0 ? emits[0] : 0;
        uint8_t s1 = cnt > 1 ? emits[1] : 0;
        int next = index[n];
        out << "  { " << next << ", " << cnt << ", {" << int(s0) << ","
            << int(s1) << "} },\n";
      }
    }
  }

  out << "};\n\n";

  // This is too naive
  // Emit accepting‐state flags (root OR EOS leaf)
  // out << "inline constexpr bool kAccepting[" << nodes.size() << "] = {\n";
  // for (size_t i = 0; i < nodes.size(); ++i) {
  //   bool is_accept = (nodes[i] == root) || (nodes[i]->symbol == 256);
  //   out << (is_accept ? "  true" : "  false");
  //   if (i + 1 < nodes.size())
  //     out << ",";
  //   out << "\n";
  // }
  // out << "};\n";

  // ----------------------------------------------------------------------
  // 2. Compute Emit accepting‐state flags via in-memory trie simulation
  // ----------------------------------------------------------------------
  out << "inline constexpr bool kAccepting[" << nodes.size() << "] = {\n";
  for (size_t i = 0; i < nodes.size(); ++i) {
    bool valid = false;
    Node* cur = nodes[i];
    // Try feeding up to 32 one-bits
    for (int step = 0; step < 32; ++step) {
      Node* next = cur->child[1];
      if (!next) {
        // invalid transition → padding here would emit error
        break;
      }
      if (next->symbol >= 0) {
        // hitting a symbol resets to root
        if (next->symbol == 256) {
          valid = true;  // reached EOS leaf
        }
        cur = root;
      } else {
        cur = next;
      }
      if (valid)
        break;
    }
    out << (valid ? "  true" : "  false");
    if (i + 1 < nodes.size())
      out << ", ";
    out << "\n";
  }
  out << "};\n\n";

  // ----------------------------------------------------------------------
  // 3. Compute bit-depth for each state (distance from last symbol emission)
  // ----------------------------------------------------------------------
  std::vector<uint8_t> stateDepth(nodes.size());
  // We know root (state 0) is depth 0
  stateDepth[0] = 0;
  // Use a queue for BFS
  std::queue<Node*> dq;
  dq.push(root);
  std::vector<bool> seen(nodes.size());
  seen[0] = true;
  while (!dq.empty()) {
    Node* cur = dq.front();
    dq.pop();
    int idx = index[cur];
    for (int bit = 0; bit < 2; ++bit) {
      Node* c = cur->child[bit];
      if (c) {
        int ci = index[c];
        if (!seen[ci]) {
          // each child is one bit further from its parent
          stateDepth[ci] = uint8_t(stateDepth[idx] + 1);
          seen[ci] = true;
          dq.push(c);
        }
      }
    }
  }

  // ----------------------------------------------------------------------
  // 4. Compute & Emit the depth table
  //    State bit-depth: how many bits into current codeword
  // ----------------------------------------------------------------------
  out << "// State bit-depth: how many bits into current codeword\n";
  out << "inline constexpr uint8_t kStateDepth[" << nodes.size() << "] = {";
  for (size_t i = 0; i < stateDepth.size(); ++i) {
    out << int(stateDepth[i]);
    if (i + 1 < stateDepth.size())
      out << ", ";
  }
  out << "};\n\n";

  // ------------------------------------------------------------------------
  // 5. Emit the bit-level transition table:
  //
  //    For each FSM state and each possible single bit (0 or 1), we need
  //    to know (a) what next_state we’d end up in, and (b) how many symbols
  //    (0 or 1) that bit would emit.  In HPACK, feeding a padding bit '1'
  //    must never emit a symbol.
  // ------------------------------------------------------------------------
  out << "struct BitDecodeEntry {\n"
         "  uint16_t next_state;\n"
         "  uint8_t  emit_count;\n"
         "};\n\n"
         "inline constexpr BitDecodeEntry kBitTable["
      << nodes.size() << "][2] = {\n";

  // We already have `nodes` and the same trie used for bytes.  We just walk
  // one bit at a time from each state:
  for (size_t st = 0; st < nodes.size(); ++st) {
    out << "  { ";
    for (int bit = 0; bit < 2; ++bit) {
      Node* n = nodes[st];
      // follow a single bit
      if (n->child[bit]) {
        n = n->child[bit];
      } else {
        // invalid transition: mark as error state (never used in padding)
        out << "{ 0xFFFF, 0xFF }";
        if (bit == 0)
          out << ", ";
        continue;
      }

      // if we landed on a symbol, that would be an emit_count=1 and we reset
      // to root; otherwise emit_count=0 and stay in this node.
      // bool is_leaf = (n->symbol >= 0);
      // uint16_t next = is_leaf ? /*root=*/0 : static_cast<uint16_t>(st);
      bool is_leaf = (n->symbol >= 0);
      // child ‘n’ gives next_state = its index(), unless it’s a leaf (reset to
      // root)
      uint16_t next = is_leaf ? /*root=*/0 : static_cast<uint16_t>(index[n]);

      uint8_t cnt = is_leaf ? 1 : 0;
      out << "{ " << next << ", " << int(cnt) << " }";
      if (bit == 0)
        out << ", ";
    }
    out << " },\n";
  }
  out << "};\n\n";

  // ----------------------------------------------------------------------
  // 6) Namespace closure
  // ----------------------------------------------------------------------
  out << "} } } }\n"
      << "/* clang-format off */";

  std::cout << "Generated Huffman FSM with " << nodes.size() << " states to "
            << out_path << "\n";
  return 0;
}
}  // namespace huffman_full_byte
}  // namespace codegen
}  // namespace h2v