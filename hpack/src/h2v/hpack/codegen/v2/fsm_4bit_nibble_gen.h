// File: fsm_4bit_nibble.h
//
// This produces a single file "huffman_nibble_table.cc" containing:
//   - kNibbleDecodeTable[512*16]    (packed 32-bit entries, exactly 32,768 bytes (32KB))
//   - kAcceptingNibbleBits[65]      (513-bit bitmask in 65 bytes)
//   - kBitTableNibble[512][2]       (each entry 2 bytes → ~2,048 bytes)
// In total, the decode-only data is < 36 KiB, and the 32 KiB “hot nibble table”
// fits precisely in L1-D.
#pragma once
#include <array>
#include <cassert>
#include <cstdint>
#include <cstring>
#include <fstream>
#include <iostream>
#include <queue>
#include <string>
#include <unordered_map>
#include <vector>
#include "huffman_table.h"

namespace h2v {
namespace codegen {
namespace huffman_4bit_nibble {



// -----------------------------------------------------------------------------
// 2) Build an in-memory Huffman trie for 257 symbols (0–255 plus 256 = EOS)
// -----------------------------------------------------------------------------
struct Node {
  Node* child[2] = {nullptr, nullptr};
  int symbol = -1;  // 0..255 = byte, 256 = EOS, -1 = interior
};

static Node* BuildTrie() {
  Node* root = new Node();
  for (int sym = 0; sym < 257; ++sym) {
    uint32_t code =codegen::huffman::CODE[sym];
    uint8_t length = codegen::huffman::LEN[sym];
    Node* p = root;
    for (int i = length - 1; i >= 0; --i) {
      int bit = (code >> i) & 1;
      if (!p->child[bit]) {
        p->child[bit] = new Node();
      }
      p = p->child[bit];
    }
    p->symbol = sym;  // mark leaf
  }
  return root;
}

static void DeleteTrie(Node* n) {
  if (!n)
    return;
  DeleteTrie(n->child[0]);
  DeleteTrie(n->child[1]);
  delete n;
}

// -----------------------------------------------------------------------------
// 3) BFS - assign an index to each node in the trie, then prune EOS leaf
// -----------------------------------------------------------------------------
static void IndexAndPruneEOS(Node* root, std::vector<Node*>& nodesOld,
                             std::unordered_map<Node*, int>& indexOld,
                             Node*& eosNode) {
  // (1) BFS to collect all nodes (513 of them) and assign old indices 0..512
  std::queue<Node*> q;
  q.push(root);
  indexOld[root] = 0;
  nodesOld.push_back(root);

  while (!q.empty()) {
    Node* cur = q.front();
    q.pop();
    int idx = indexOld[cur];
    for (int b = 0; b < 2; ++b) {
      Node* c = cur->child[b];
      if (c && indexOld.find(c) == indexOld.end()) {
        int newIdx = (int)nodesOld.size();
        indexOld[c] = newIdx;
        nodesOld.push_back(c);
        q.push(c);
      }
    }
  }

  // (2) Find the unique node whose symbol==256 → that's the EOS leaf
  eosNode = nullptr;
  for (Node* n : nodesOld) {
    if (n->symbol == 256) {
      eosNode = n;
      break;
    }
  }
  assert(eosNode != nullptr);  // sanity: must exist exactly one EOS leaf
}

// Build a mapping from “old index” → “new index in [0..511]” by skipping the
// EOS‐leaf
static void BuildNewIndexMap(const std::vector<Node*>& nodesOld,
                             const std::unordered_map<Node*, int>& indexOld,
                             Node* eosNode, std::vector<int>& mapOldToNew,
                             std::vector<Node*>& nodesNew) {
  int oldCount = (int)nodesOld.size();  // should be 513
  mapOldToNew.resize(oldCount, -1);
  nodesNew.reserve(oldCount - 1);

  int newIdx = 0;
  for (int oldIdx = 0; oldIdx < oldCount; ++oldIdx) {
    Node* n = nodesOld[oldIdx];
    if (n == eosNode)
      continue;  // skip exactly the EOS leaf
    mapOldToNew[oldIdx] = newIdx;
    nodesNew.push_back(n);
    ++newIdx;
  }
  assert(newIdx == oldCount - 1);  // now we have 512 states
}

// -----------------------------------------------------------------------------
// 4) Emit the C++ tables: packed nibble decode, accepting bits, bit‐table,
// encode
// -----------------------------------------------------------------------------
static void EmitNibbleTables(std::ofstream& out,
                             const std::vector<Node*>& nodesOld,
                             const std::unordered_map<Node*, int>& indexOld,
                             const std::vector<Node*>& nodesNew,
                             const std::vector<int>& mapOldToNew, Node* root,
                             Node* eosNode) {
  size_t NUM_OLD = nodesOld.size();  // 513
  size_t NUM_NEW = nodesNew.size();  // 512

  // -------------------------------------------------------------------------
  // 4.1) Header + type definitions
  // -------------------------------------------------------------------------
  out << "// @generated by h2v_huffman_gen_v2\n";
  out << "// NOTE: DO NOT EDIT THIS DIRECTLY\n";
  out << "// This generated table use by huffman::FastDecode(...)\n";
  out << "/* clang-format off*/\n";
  out << "#pragma once\n";
  out << "#include <cstdint>\n\n";
  out << "namespace h2v { namespace hpack { namespace huffman { namespace "
         "table {\n\n";

  out << "// --- 1) packed nibble decode table: 512 states × 16 nibbles = 8192 "
         "entries → 32 768 bytes\n";
  out << "using NibblePackedEntry = uint32_t;\n";
  out << "static constexpr NibblePackedEntry kNibbleDecodeTable["
      << (NUM_NEW * 16) << "] = {\n";

  // For each NEW state (0..511), produce exactly 16 packed entries in row-major
  // order. But we only know NEW state ↔ Node*; we need to find the
  // corresponding OLD index to traverse children.
  for (int newSt = 0; newSt < (int)NUM_NEW; ++newSt) {
    Node* currNew = nodesNew[newSt];
    // Find old index of this node:
    int oldSt = indexOld.at(currNew);

    for (int nib = 0; nib < 16; ++nib) {
      // Walk EXACTLY 4 bits from oldSt
      Node* n = currNew;
      bool isError = false;
      std::vector<uint8_t> emits;

      for (int i = 3; i >= 0; --i) {
        int bit = (nib >> i) & 1;
        n = n->child[bit];
        if (!n) {
          // Fell off the trie → invalid nibble‐prefix
          isError = true;
          break;
        }
        if (n->symbol >= 0) {
          // If it's a “real symbol” (0..255), we emit it
          if (n->symbol < 256) {
            emits.push_back(static_cast<uint8_t>(n->symbol));
            n = root;  // reset to root
          } else {
            // If it's EOS (256), that prefix is never valid in a real input
            isError = true;
            break;
          }
        }
      }

      // If not error, we now end at n (an old Node*), which is necessarily not
      // the EOS leaf.
      uint32_t packed = 0;
      if (isError) {
        // bit31 = 1 → indicates “invalid prefix”
        packed = (1u << 31);
      } else {
        // next_state = newIndex( oldIndex(n) )    → 9 bits
        int oldNextIdx = indexOld.at(n);
        int newNext = mapOldToNew[oldNextIdx];
        assert(newNext >= 0 && newNext < (int)NUM_NEW);

        // emit_count = emits.size()  (0,1 or 2) → 2 bits
        uint32_t ec = static_cast<uint32_t>(emits.size() & 0x03);

        uint32_t s0 = (emits.size() > 0 ? emits[0] : 0);
        uint32_t s1 = (emits.size() > 1 ? emits[1] : 0);

        // pack into 32 bits:
        //  bit31      = 0
        //  bits30..22 = next_state (9 bits)
        //  bits21..20 = emit_count (2 bits)
        //  bits19..12 = s0 (8 bits)
        //  bits11..4  = s1 (8 bits)
        //  bits3..0   = 0
        packed = (uint32_t(newNext & 0x01FF) << 22) | (ec << 20) |
                 ((s0 & 0xFF) << 12) | ((s1 & 0xFF) << 4);
      }

      // Output as hex, comma/newline except last entry
      out << "  0x" << std::hex << packed << std::dec;
      bool isLast = (newSt == (int)NUM_NEW - 1 && nib == 15);
      if (!isLast)
        out << ",\n";
      else
        out << "\n";
    }
  }
  out << "};\n\n";

  // -------------------------------------------------------------------------
  // 4.2) Emit kAcceptingNibbleBits: a 513-bit bitmask (we store in 9×64=576
  // bits = 72 bytes, but we only need 513 bits; the extra bits are zero). We
  // only care about the 512 “new states,” but for padding‐check we also want to
  // know if feeding zero bits from “EOS leaf” is accepting, so we’ll include
  // its bit as well (i.e. 513 bits total). We lay those out as a uint64_t
  // array.
  // -------------------------------------------------------------------------
  {
    size_t words = (NUM_OLD + 63) / 64;  // i.e. (513+63)/64 = 9 words
    std::vector<uint64_t> acceptBits(words, 0ull);

    for (int oldSt = 0; oldSt < (int)NUM_OLD; ++oldSt) {
      Node* cur = nodesOld[oldSt];
      bool valid = false;
      // simulate feeding up to 32 “1” bits
      for (int step = 0; step < 32; ++step) {
        Node* next = cur->child[1];  // feed bit=1
        if (!next) {
          valid = false;
          break;
        }
        if (next->symbol >= 0) {
          if (next->symbol == 256) {
            valid = true;
          }
          // any symbol (0..255) also resets to root, but that means padding is
          // invalid.
          break;
        }
        cur = next;
      }
      if (valid) {
        size_t w = oldSt / 64, b = oldSt % 64;
        acceptBits[w] |= (1ull << b);
      }
    }

    out << "// --- 2) accepting bits for nibble-FSM (513 bits) → stored as "
           "9×64-bit = 72 bytes\n";
    out << "static constexpr uint64_t kAcceptingNibbleBits[" << words
        << "] = {\n";
    for (size_t w = 0; w < words; ++w) {
      out << "  0x" << std::hex << acceptBits[w] << std::dec;
      if (w + 1 < words)
        out << ",";
      out << "\n";
    }
    out << "};\n\n";
  }

  // -------------------------------------------------------------------------
  // 4.3) Emit kBitTableNibble[512][2]: for each NEW state, for bit=0/1,
  // we store a 16-bit entry: [bit15] = error flag (1=invalid),
  // [bits14..6]=next_state(9b), [bits5..0]=0 (emit_count is always 0, because
  // if a single bit leads to a leaf or EOS, that is "invalid for padding").
  // This totals 512×2×2 bytes = 2048 bytes.
  // -------------------------------------------------------------------------
  out << "// --- 3) bit table for nibble-FSM (512 states × 2 bits × 2 bytes ≈ "
         "2048 bytes)\n";
  out << "struct BitDecodeNibbleEntry { uint16_t next_state; uint8_t is_error; "
         "};\n";
  out << "static constexpr BitDecodeNibbleEntry kBitTableNibble[" << NUM_NEW
      << "][2] = {\n";

  for (int newSt = 0; newSt < (int)NUM_NEW; ++newSt) {
    Node* currNew = nodesNew[newSt];
    int oldSt = indexOld.at(currNew);
    out << "  { ";
    for (int bit = 0; bit < 2; ++bit) {
      Node* n = currNew->child[bit];
      bool err = false;
      int nextNew = 0;
      if (!n) {
        err = true;
      } else if (n->symbol >= 0) {
        // either a real symbol or EOS → invalid for padding
        err = true;
      } else {
        int oldNext = indexOld.at(n);
        nextNew = mapOldToNew[oldNext];  // 0..511
      }
      // pack into a 16-bit: bit15=error, bits14..6 = next_state (9 bits),
      // bits5..0 = unused=0
      uint16_t entry =
          (uint16_t(err ? 1 : 0) << 15) | (uint16_t(nextNew & 0x01FF) << 6);
      out << "{ " << entry << ", " << (err ? 1 : 0) << " }";
      if (bit == 0)
        out << ", ";
    }
    out << " }";
    if (newSt + 1 < (int)NUM_NEW)
      out << ",";
    out << "\n";
  }
  out << "};\n\n";

  out << "} } } }  // namespace h2v::hpack::huffman::table\n";
  out << "/* clang-format on*/\n";
}

// -----------------------------------------------------------------------------
// 5) GenerateFsm4BitNibble(): build trie, prune, and emit
// -----------------------------------------------------------------------------
int GenerateFsm4BitNibble(const std::string& out_path) {
  // Build full Huffman trie
  Node* root = BuildTrie();

  // (1) BFS index + find EOS leaf
  std::vector<Node*> nodesOld;
  nodesOld.reserve(600);
  std::unordered_map<Node*, int> indexOld;
  indexOld.reserve(600);
  Node* eosNode = nullptr;
  IndexAndPruneEOS(root, nodesOld, indexOld, eosNode);

  // (2) Build newIndex mapping and nodesNew[]
  std::vector<int> mapOldToNew;
  std::vector<Node*> nodesNew;
  nodesNew.reserve(nodesOld.size() - 1);
  BuildNewIndexMap(nodesOld, indexOld, eosNode, mapOldToNew, nodesNew);

  // Open output file
  std::ofstream out(out_path, std::ios::trunc);
  if (!out) {
    std::cerr << "Error: cannot open " << out_path << "\n";
    DeleteTrie(root);
    return 1;
  }

  // Emit the 4 tables
  EmitNibbleTables(out, nodesOld, indexOld, nodesNew, mapOldToNew, root,
                   eosNode);

  out.close();
  DeleteTrie(root);
  std::cout << "→ Generated nibble tables (512 states) to " << out_path << "\n";
  return 0;
}
}  // namespace huffman_4bit_nibble
}  // namespace codegen
}  // namespace h2v
